program q2; implicit none

real, parameter :: dx = 1e-2            ! step size
integer, parameter :: n = 5             ! number of calculated even and odd eigenvalues (2n total)
integer i                               ! counter
real y(2), evenvals(n,2), oddvals(n,2)  ! y: "psi" and "d(psi)/dx", "vals" will hold the eigenvalues and normalization constants
 

! Find theeigenvalues and normalization constants for the first n odd and first n even modes
write(*,*) "...calculating eigenvalues for question 2..."
!$omp parallel do
do i = 1,n
    evenvals(i,:) = bisecteven(2.0*(i-1), 2.0*i)
    oddvals(i,:) = bisectodd(2.0*(i-1), 2.0*i)
    write(*,*) evenvals(i,:)
    write(*,*) oddvals(i,:)
end do
!$omp end parallel do

write(*,*) "...writing files with probability distributions for question 2..."
do i = 1, 2*n
    if (mod(i,2) == 1) then     ! even mode
        y(1) = 1.0; y(2) = 0.0 
        call savedata (evenvals(i/2+1,1), evenvals(i/2+1,2), y, i-1)
        !write(*,*) i/2+1
    else if (mod(i,2) == 0) then    ! odd mode
        y(1) = 0.0; y(2) = 1.0
        call savedata (oddvals(i/2,1), oddvals(i/2 ,2), y, i-1) 
        !write(*,*) i/2
    end if  
end do

    

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Knowing the energy eigenvalue and the normalization constant, write the normalized solution to file
! y lets us set even/odd initial condition, i sets the mode
subroutine savedata(energy, norm, y, i)
    real energy, norm, x, y(2)
    integer i
    character (len = 12) :: filename
    
    x = 0.0
    
    write(filename, fmt = '(a, I2.2, a)') "mode",i, ".dat"
    open(unit = i, file = filename)
    do while ( abs(y(1)) < 4.0 .and. ( abs(y(1)) > 0.1 .or. abs(y(2)) > 0.1 ) )       
        ! step forward with Gauss-Legendre 8th order
        write(i,*) x, y(1)**2/(2*norm)
        call gl8(x, y, dx, energy)
        x = x + dx
     end do
end subroutine


! Find whether for given energy and initial condition ("calceven"' for even fucntion, "calcodd" for odd function) we blow up to positive or negative infinity
! Used in bisection function: eigenvalue is located where we switch "direction of blowing up" between positive and negative infinity
function calceven(energy)
    real x, y(2)
    real energy, calceven(2), norm
    
    x = 0.0 
    y = (/ 1.0, 0.0 /)      ! Initial condition for an even function
    norm = y(1)**2
    
    do while ( abs(y(1)) < 4.0 .and. ( abs(y(1)) > 0.1 .or. abs(y(2)) > 0.1 ) )       
        ! step forward with Gauss-Legendre 8th order
        call gl8(x, y, dx, energy)
        x = x + dx
        norm = norm + dx*y(1)**2
     end do
     
     calceven(1) = y(1)      ! Tells us whether we blow up to positive or negative infinity
     calceven(2) = norm      ! Holds a normalization constant for given energy
end function


function calcodd(energy)
    real x, y(2)
    real energy, calcodd(2), norm
    
    x = 0.0 
    y = (/ 0.0, 1.0 /)      ! Initial condition for an odd function
    norm = y(1)**2
    
    do while ( abs(y(1)) < 4.0 .and. ( abs(y(1)) > 0.1 .or. abs(y(2)) > 0.1 ) )       
        ! step forward with Gauss-Legendre 8th order
        call gl8(x, y, dx, energy)
        x = x + dx
        norm = norm + dx*y(1)**2
     end do
     
     calcodd(1) = y(1)      ! Tells us whether we blow up to positive or negative infinity
     calcodd(2) = norm      ! Holds a normalization constant for given energy
end function


! Looks for even eigenvalues in a defined interval
function bisecteven(Emin, Emax)
	real Emin, Emax, bisecteven(2)
	real a, b, c, fa(2), fb(2), fc(2)
	real, parameter :: eps = 1.0e-12
	
	a = Emin; fa = calceven(a)
	b = Emax; fb = calceven(b)
	
	if (fa(1)*fb(1) > 0) then
	    write(*,*) "There are no eigenvalues in one of the defined intervals"
        call abort
	end if 
	
 do while (abs(b-a) > eps)
    write(*,*) c
		c = (a+b)/2.0; fc = calceven(c); if (abs(fc(1)) < 0.001) exit
		if (fa(1)*fc(1) < 0.0) then; b = c; fb = fc; end if
		if (fc(1)*fb(1) < 0.0) then; a = c; fa = fc; end if
	end do
	
	bisecteven(1) = c       ! Holds eigenvalue
	bisecteven(2) = fc(2)   ! Holds normalization 
end function


! Looks for even eigenvalues in a defined interval
function bisectodd(Emin, Emax)
	real Emin, Emax, bisectodd(2)
	real a, b, c, fa(2), fb(2), fc(2)
	real, parameter :: eps = 1.0e-12
	
	a = Emin; fa = calcodd(a)
	b = Emax; fb = calcodd(b)
	
	if (fa(1)*fb(1) > 0) then
	    write(*,*) "There are no eigenvalues in one of the defined intervals"
        call abort
	end if
	
	do while (abs(b-a) > eps)
		c = (a+b)/2.0; fc = calcodd(c); if (abs(fc(1)) < 0.001) exit
		if (fa(1)*fc(1) < 0.0) then; b = c; fb = fc; end if
		if (fc(1)*fb(1) < 0.0) then; a = c; fa = fc; end if
	end do
	
	bisectodd(1) = c        ! Holds eigenvalue
	bisectodd(2) = fc(2)    ! Holds normalization 
end function


! Define potential
pure function V(x)
        real V, x
        intent(in) x
        V = 0.5*x**2        
end function


! Change a 2nd order ODE (Schrodinger eqn) to two 1st order ones - evaluate derivatives
subroutine evalf(x, y, dydx, E)
        real x, y(2), dydx(2), E
        
        dydx(1) = y(2)
        dydx(2) = 2*(V(x) - E)*y(1)
end subroutine evalf


! 8th order implicit Gauss-Legendre integrator, DON'T TOUCH - BLACK MAGIC
subroutine gl8(x, y, dx, E)
        integer, parameter :: s = 4, n = 2
        real x, y(n), g(n,s), E, dx; integer i, k
        
        ! Butcher tableau for 8th order Gauss-Legendre method
        real, parameter :: a(s,s) = reshape((/ &
                 0.869637112843634643432659873054998518Q-1, -0.266041800849987933133851304769531093Q-1, &
                 0.126274626894047245150568805746180936Q-1, -0.355514968579568315691098184956958860Q-2, &
                 0.188118117499868071650685545087171160Q0,   0.163036288715636535656734012694500148Q0,  &
                -0.278804286024708952241511064189974107Q-1,  0.673550059453815551539866908570375889Q-2, &
                 0.167191921974188773171133305525295945Q0,   0.353953006033743966537619131807997707Q0,  &
                 0.163036288715636535656734012694500148Q0,  -0.141906949311411429641535704761714564Q-1, &
                 0.177482572254522611843442956460569292Q0,   0.313445114741868346798411144814382203Q0,  &
                 0.352676757516271864626853155865953406Q0,   0.869637112843634643432659873054998518Q-1 /), (/s,s/))
        real, parameter ::   b(s) = (/ &
                 0.173927422568726928686531974610999704Q0,   0.326072577431273071313468025389000296Q0,  &
                 0.326072577431273071313468025389000296Q0,   0.173927422568726928686531974610999704Q0  /)
        
        ! iterate trial steps
        g = 0.0; do k = 1,12
                g = matmul(g,a)
                do i = 1,s
                        call evalf(x, y + g(:,i)*dx, g(:,i), E)
                end do
        end do
        
        ! update the solution
        y = y + matmul(g,b)*dx
end subroutine gl8

end
